#!/usr/bin/env python
import os
import sys
import argparse
import traceback
import csv
import glob
import json
import numpy as np
import pandas as pd
from scipy import io


def main():
  parser = argparse.ArgumentParser(description='Publishes rows of data.')
  parser.add_argument('-i', '--input-dir', help='The directory with the raw CSV files to be processed', required=True)
  parser.add_argument('-o', '--output-dir', help='The directory to place the converted CSV data', required=True)
  parser.add_argument('-v', '--verbose', help='Prints out the verbose processing information', action='store_true', default=False)
  parser.add_argument(      '--verbose-help', help='Prints out the verbose help menu', action='store_true', default=False)
  args = parser.parse_args()

  args.input_dir = os.path.join(os.path.abspath(args.input_dir), '')
  args.output_dir = os.path.join(os.path.abspath(args.output_dir), '')

  os.makedirs(args.output_dir, exist_ok=True)

  # Check if we're just using the verbose output
  if args.verbose_help:
    print('More help')
    sys.exit()

  try:
    for name in glob.glob(f'{args.input_dir}/**/*.csv', recursive=True):
      ignore = ['LTF', 'MEG', 'Purge']
      if any(filter(lambda i: i in name, ignore)):
        continue
      # Read the data into a pandas data frame and remove all the duplicate lines to only leave the latest updated row.
      df=pd.read_csv(name, sep=',', low_memory=False)
      if('Systems.csv' in name or 'GNCA.csv' in name):
        opath = os.path.join(args.output_dir, os.path.basename(name).split('_')[0])
        print(f'Processing: {name.split(args.input_dir)[-1]} to {opath}')
        
        # We are going to filter on any SUBSEC column in the CSV.  That's where the data will be aligned for the current timestep
        keys = list(filter(lambda k: 'SUBSEC' in k, df.columns))
        if any(keys):
          if args.verbose:
            print(f'Filtering on {keys[0]} in {name.split(args.input_dir)[-1]}')

          ## np.where and np.roll are apparently the key
          ## https://stackoverflow.com/questions/19125661/find-index-where-elements-change-value-numpy
          v = df[keys[0]]  # TODO: This should verify that it's only a single key been found
          idx = np.where(np.roll(v,-1)!=v)[0]

          # Make the column names something easier to understand
          lookup = json.load(open('lookup.json'))
          #Time,TM.ROBIN0ADEV02:GNCA.NAV.TPSH.MET_SEC.Uncal,TM.ROBIN0ADEV02:GNCA.NAV.TPSH.MET_SUBSEC.Uncal,TM.ROBIN0ADEV02:GNCA.NAV.SC_ALT.Cal,TM.ROBIN0ADEV02:GNCA.NAV.SC_ALT_MEAS.Cal,TM.ROBIN0ADEV02:GNCA.NAV.SC_POS[0].Cal,TM.ROBIN0ADEV02:GNCA.NAV.SC_POS[1].Cal,TM.ROBIN0ADEV02:GNCA.NAV.SC_POS[2].Cal,TM.ROBIN0ADEV02:GNCA.NAV.TOUCHDOWN_FLAG.Cal,TM.ROBIN0ADEV02:GNCA.GUID.CMD_QUAT[0].Cal,TM.ROBIN0ADEV02:GNCA.GUID.CMD_QUAT[1].Cal,TM.ROBIN0ADEV02:GNCA.GUID.CMD_QUAT[2].Cal,TM.ROBIN0ADEV02:GNCA.GUID.CMD_QUAT[3].Cal,TM.ROBIN0ADEV02:GNCA.ADS.ATT_EST.QUAT_I2B[0].Cal,TM.ROBIN0ADEV02:GNCA.ADS.ATT_EST.QUAT_I2B[1].Cal,TM.ROBIN0ADEV02:GNCA.ADS.ATT_EST.QUAT_I2B[2].Cal,TM.ROBIN0ADEV02:GNCA.ADS.ATT_EST.QUAT_I2B[3].Cal,TM.ROBIN0ADEV02:GNCA.NAV.SC_VEL[0].Cal,TM.ROBIN0ADEV02:GNCA.NAV.SC_VEL[1].Cal,TM.ROBIN0ADEV02:GNCA.NAV.SC_VEL[2].Cal,TM.ROBIN0ADEV02:GNCA.CONTROL.ANG_ERR[0].Cal,TM.ROBIN0ADEV02:GNCA.CONTROL.ANG_ERR[1].Cal,TM.ROBIN0ADEV02:GNCA.CONTROL.ANG_ERR[2].Cal,TM.ROBIN0ADEV02:GNCA.CONTROL.RATE_ERR[0].Cal,TM.ROBIN0ADEV02:GNCA.CONTROL.RATE_ERR[1].Cal,TM.ROBIN0ADEV02:GNCA.CONTROL.RATE_ERR[2].Cal,TM.ROBIN0ADEV02:GNCA.NAV.SC_ACC[0].Cal,TM.ROBIN0ADEV02:GNCA.NAV.SC_ACC[1].Cal,TM.ROBIN0ADEV02:GNCA.NAV.SC_ACC[2].Cal,TM.ROBIN0ADEV02:GNCA.THRUSTER.PHASE_PLANE_ANGLE_ERROR[0].Cal,TM.ROBIN0ADEV02:GNCA.THRUSTER.PHASE_PLANE_ANGLE_ERROR[1].Cal,TM.ROBIN0ADEV02:GNCA.THRUSTER.PHASE_PLANE_ANGLE_ERROR[2].Cal,TM.ROBIN0ADEV02:GNCA.THRUSTER.PHASE_PLANE_ANGLE_ERROR[4].Cal,TM.ROBIN0ADEV02:GNCA.THRUSTER.PHASE_PLANE_ANGLE_ERROR[5].Cal,TM.ROBIN0ADEV02:GNCA.THRUSTER.PHASE_PLANE_ANGLE_ERROR[6].Cal,TM.ROBIN0ADEV02:GNCA.THRUSTER.PHASE_PLANE_RATE_ERROR[0].Cal,TM.ROBIN0ADEV02:GNCA.THRUSTER.PHASE_PLANE_RATE_ERROR[1].Cal,TM.ROBIN0ADEV02:GNCA.THRUSTER.PHASE_PLANE_RATE_ERROR[2].Cal,TM.ROBIN0ADEV02:GNCA.THRUSTER.PHASE_PLANE_RATE_ERROR[4].Cal,TM.ROBIN0ADEV02:GNCA.THRUSTER.PHASE_PLANE_RATE_ERROR[5].Cal,TM.ROBIN0ADEV02:GNCA.THRUSTER.PHASE_PLANE_RATE_ERROR[6].Cal,TM.ROBIN0ADEV02:GNCA.THR_FIRE.THRUSTER_FIRE.EA01_ENABLE_DURATION.Cal,TM.ROBIN0ADEV02:GNCA.THR_FIRE.THRUSTER_FIRE.EA02_ENABLE_DURATION.Cal,TM.ROBIN0ADEV02:GNCA.THR_FIRE.THRUSTER_FIRE.EA03_ENABLE_DURATION.Cal,TM.ROBIN0ADEV02:GNCA.THR_FIRE.THRUSTER_FIRE.EA04_ENABLE_DURATION.Cal,TM.ROBIN0ADEV02:GNCA.THR_FIRE.THRUSTER_FIRE.EA05_ENABLE_DURATION.Cal,TM.ROBIN0ADEV02:GNCA.THR_FIRE.THRUSTER_FIRE.EA07_ENABLE_DURATION.Cal,TM.ROBIN0ADEV02:GNCA.THR_FIRE.THRUSTER_FIRE.ED01_ENABLE_DURATION.Cal,TM.ROBIN0ADEV02:THROTL.THROTL_POS.EGC_THROTL_PSTN.Cal,TM.ROBIN0ADEV02:GNCA.ADS.ATT_EST.ANG_RATE[0].Cal,TM.ROBIN0ADEV02:GNCA.ADS.ATT_EST.ANG_RATE[1].Cal,TM.ROBIN0ADEV02:GNCA.ADS.ATT_EST.ANG_RATE[2].Cal,TM.ROBIN0ADEV02:GNCA.ADS.IMU.ACC_MEASUREMENT[0].Cal,TM.ROBIN0ADEV02:GNCA.ADS.IMU.ACC_MEASUREMENT[1].Cal,TM.ROBIN0ADEV02:GNCA.ADS.IMU.ACC_MEASUREMENT[2].Cal,TM.ROBIN0ADEV02:GNCA.CONTROL.RTW_VALID_TIME.Cal,TM.ROBIN0ADEV02:GNCA.ADS.RTW_VALID_TIME.Cal,TM.ROBIN0ADEV02:GNCA.GUID.RTW_VALID_TIME.Cal,TM.ROBIN0ADEV02:GNCA.THRUSTER.RTW_VALID_TIME.Cal,TM.ROBIN0ADEV02:GNCA.THR_FIRE.THRUSTER_FIRE.RTW_VALID_TIME.Cal,TM.ROBIN0ADEV02:VSM.STATUS.VEHICLE_STATE.Uncal,TM.ROBIN0ADEV02:GNCA.ADS.IMU.ACC_BIAS[0].Cal,TM.ROBIN0ADEV02:GNCA.ADS.IMU.ACC_BIAS[1].Cal,TM.ROBIN0ADEV02:GNCA.ADS.IMU.ACC_BIAS[2].Cal,TM.ROBIN0ADEV02:GNCA.NAV.STATE_CORRECTION[0].Cal,TM.ROBIN0ADEV02:GNCA.NAV.STATE_CORRECTION[1].Cal,TM.ROBIN0ADEV02:GNCA.NAV.STATE_CORRECTION[2].Cal,TM.ROBIN0ADEV02:GNCA.NAV.STATE_CORRECTION[3].Cal,TM.ROBIN0ADEV02:GNCA.NAV.STATE_CORRECTION[4].Cal,TM.ROBIN0ADEV02:GNCA.NAV.STATE_CORRECTION[5].Cal,TM.ROBIN0ADEV02:GNCA.NAV.STATE_CORRECTION[6].Cal,TM.ROBIN0ADEV02:GNCA.NAV.LAST_SLOW_NAV_TIME.Cal,TM.ROBIN0ADEV02:ALT.PKT.FRAME.SC_ALTITUDE.Cal,TM.ROBIN0ADEV02:ALT.PKT.FRAME.SC_ALTITUDE_VLD.Uncal,TM.ROBIN0ADEV02:GNCT.INPUTS.IMU_ACC_BIAS[0].Cal,TM.ROBIN0ADEV02:GNCT.INPUTS.IMU_ACC_BIAS[1].Cal,TM.ROBIN0ADEV02:GNCT.INPUTS.IMU_ACC_BIAS[2].Cal,TM.ROBIN0ADEV02:GNCT.INPUTS.XCM[0].Cal,TM.ROBIN0ADEV02:GNCT.INPUTS.XCM[1].Cal,TM.ROBIN0ADEV02:GNCT.INPUTS.XCM[2].Cal,TM.ROBIN0ADEV02:GNCT.INPUTS.XCM[3].Cal,TM.ROBIN0ADEV02:GNCT.INPUTS.XCM[4].Cal,TM.ROBIN0ADEV02:GNCT.INPUTS.XCM[5].Cal,TM.ROBIN0ADEV02:GNCT.INPUTS.XCM[6].Cal,TM.ROBIN0ADEV02:GNCT.INPUTS.XCM[7].Cal,TM.ROBIN0ADEV02:GNCT.INPUTS.XCM[8].Cal,TM.ROBIN0ADEV02:GNCT.INPUTS.XCM[9].Cal,TM.ROBIN0ADEV02:AI.PKT2.ED01_PRESS.Cal,TM.ROBIN0ADEV02:AI.PKT2.ED02_PRESS.Cal,TM.ROBIN0ADEV02:AI.PKT2.ED03_PRESS.Cal,TM.ROBIN0ADEV02:AI.PKT2.EGC_PRESS.Cal,TM.ROBIN0ADEV02:GNCA.NAV.ALT_VALID_DROPPED_COUNT.Cal,TM.ROBIN0ADEV02:GNCA.NAV.ALT_VALID_USED_COUNT.Cal,TM.ROBIN0ADEV02:GNCA.NAV.OPVEL_IMAGE_IDS[0].Cal,TM.ROBIN0ADEV02:GNCA.NAV.OPVEL_IMAGE_IDS[1].Cal,TM.ROBIN0ADEV02:GNCA.NAV.OPVEL_IMAGE_IDS[2].Cal,TM.ROBIN0ADEV02:GNCA.NAV.OPVEL_IMAGE_IDS[3].Cal,TM.ROBIN0ADEV02:GNCA.NAV.OPVEL_IMAGE_TIMES[0].Cal,TM.ROBIN0ADEV02:GNCA.NAV.OPVEL_IMAGE_TIMES[1].Cal,TM.ROBIN0ADEV02:GNCA.NAV.OPVEL_IMAGE_TIMES[2].Cal,TM.ROBIN0ADEV02:GNCA.NAV.OPVEL_IMAGE_TIMES[3].Cal,TM.ROBIN0ADEV02:GNCA.NAV.NAV_STAT.Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.LSOF_IMG_RCVD_FOR_STATE[0].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.LSOF_IMG_RCVD_FOR_STATE[1].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.LSOF_IMG_RCVD_FOR_STATE[2].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.LSOF_IMG_RCVD_FOR_STATE[3].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.NEW_IMAGE_THIS_SLOT[0].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.NEW_IMAGE_THIS_SLOT[1].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.NEW_IMAGE_THIS_SLOT[2].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.NEW_IMAGE_THIS_SLOT[3].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.SPARE_BIT_4[0].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.SPARE_BIT_4[1].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.SPARE_BIT_4[2].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.SPARE_BIT_4[3].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.STATE_LOCKED_END_OF_SECOND[0].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.STATE_LOCKED_END_OF_SECOND[1].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.STATE_LOCKED_END_OF_SECOND[2].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.STATE_LOCKED_END_OF_SECOND[3].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.STATE_LOCKED_START_OF_SECOND[0].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.STATE_LOCKED_START_OF_SECOND[1].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.STATE_LOCKED_START_OF_SECOND[2].Cal,TM.ROBIN0ADEV02:GNCA.NAV.AUG_INDEX.STATE_LOCKED_START_OF_SECOND[3].Cal,TM.ROBIN0ADEV02:GNCA.NAV.STATE_CORRECTION_STAT.Cal,TM.ROBIN0ADEV02:GNCA.NAV.OPVEL.LSOF_MSG_PASSED_FILTER_GATE.Cal,TM.ROBIN0ADEV02:GNCA.NAV.OPVEL.LSOF_OUT_MSG_RECEIVED.Cal,TM.ROBIN0ADEV02:GNCA.NAV.OPVEL.IMAGE_SELECT_MSG_RECEIVED.Cal,TM.ROBIN0ADEV02:GNCA.NAV.OPVEL.VALID_IMAGE_ID_RECEIVED.Cal,TM.ROBIN0ADEV02:GNCA.NAV.OPVEL_ID.UID.Cal,TM.ROBIN0ADEV02:GNCA.NAV.OPVEL_ID.LOCK_A.Cal,TM.ROBIN0ADEV02:LSOF.LSOF_HK.QUALITY_OF_SOLUTION.Cal,TM.ROBIN0ADEV02:LSOF.LSOF_HK.WARP_ITER_CNT_L1.Cal,TM.ROBIN0ADEV02:LSOF.LSOF_HK.WARP_ITER_CNT_L2.Cal,TM.ROBIN0ADEV02:LSOF.LSOF_HK.WARP_ITER_CNT_L3.Cal,TM.ROBIN0ADEV02:LSOF.LSOF_HK.WARP_ITER_CNT_L4.Cal,TM.ROBIN0ADEV02:LSOF.LSOF_HK.WARP_SCORE.Cal,TM.ROBIN0ADEV02:LSOF.LSOF_HK.IMAGE_OVERLAP_PERCENT.Cal,TM.ROBIN0ADEV02:CAM.IWV_PKT.IWV_STATUS.Cal,TM.ROBIN0ADEV02:CAM.IWV_PKT.IWV_UID_A.Cal,TM.ROBIN0ADEV02:CAM.IWV_PKT.IWV_UID_B.Cal,TM.ROBIN0ADEV02:CAM.IWV_PKT.IWV_DELTA_POS_M_INERTIAL[0].Cal,TM.ROBIN0ADEV02:CAM.IWV_PKT.IWV_DELTA_POS_M_INERTIAL[1].Cal,TM.ROBIN0ADEV02:CAM.IWV_PKT.IWV_DELTA_POS_M_INERTIAL[2].Cal
          df.rename(columns=lookup, inplace=True)
          #print(df.columns)

          # Extract the subset of data from the original data frame using the filtered indexes
          fdf = df.iloc[idx]

          # Create the output directory and write out all the file types
          os.makedirs(opath, exist_ok=True)
          fullpath = os.path.join(opath, os.path.splitext(os.path.basename(name))[0])
          fdf.to_csv(fullpath + '.csv', index=False)
          fdf.to_pickle(fullpath + '.pkl')
          try:
            io.savemat(fullpath + '.mat', {'struct':fdf.to_dict('list')})
          except:
            traceback.print_exc()
    pass
  except KeyboardInterrupt: 
    running = False
  except:
    traceback.print_exc()


if __name__ == '__main__':
  main()

